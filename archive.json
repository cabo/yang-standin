{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-10-20T01:04:41.806554+00:00",
  "repo": "cabo/yang-standin",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOLF7SWM58ba1B",
      "title": "Address unions in schema",
      "url": "https://github.com/cabo/yang-standin/issues/2",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Unions in a schema can pose a problem, as types are going into the union that have different stand-ins or partially don't have stand-ins at all.  So we might run into the \"need to look at value\" situation that we want to avoid by using the schema to trigger stand-in use.",
      "createdAt": "2024-01-18T05:55:00Z",
      "updatedAt": "2024-01-18T05:55:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "I_kwDOLF7SWM5_8-wA",
      "title": "(editorial:) examples: cbor-pretty vs. cbor-diag",
      "url": "https://github.com/cabo/yang-standin/issues/3",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "              One editorial question would be how many of the examples should be cbor-pretty and when we can use the more compact and easy to read cbor-diag -- cbor-pretty obviously visualizes the savings much better.\r\n\r\n_Originally posted by @cabo in https://github.com/cabo/yang-standin/pull/1#discussion_r1456667920_\r\n            ",
      "createdAt": "2024-02-21T12:54:44Z",
      "updatedAt": "2024-08-13T16:31:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOLF7SWM5_9Ftf",
      "title": "Stand-ins should be orthogonal to the YANG model",
      "url": "https://github.com/cabo/yang-standin/issues/4",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Given the somewhat ossified nature of YANG models, it would severely hinder deployment if a model had to adopt stand-ins before they can be used.\r\nI'd propose to leave the whole concept out of the modeling level -- the model also doesn't say whether the encoding is to be JSON or CBOR, so why would it say something about stand-ins in CBOR.\r\n\r\nOf course, once models get stand-in aware, they might want to make optimizations for *if* stand-ins are in use.\r\nBut this could be done in a second step.",
      "createdAt": "2024-02-21T13:09:36Z",
      "updatedAt": "2024-08-15T15:54:35Z",
      "closedAt": "2024-08-15T15:54:35Z",
      "comments": [
        {
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "body": "thinking again about how to do this well, and also addressing the issue block in chapter 5:\r\n\r\n- it imho doesn't belong to YANG library at all as it is also unaware about encoding\r\n- it also doesn't belong to basic NETCONF negotiation as it is specific for CBOR \u2013 and NETCONF negotiation is primarily XML afaik \u2192 but as there is RESTCONF, we shall go for CBORCONF, specifying a completely binary protocol; this is a work for another RFC, there has been something like draft-mahesh-netconf-binary-encoding-01 and we have something drafted internally for BIRD \u2192 my suggestion would be to create another draft which would reference this draft and do all the negotiations\r\n- media-type parameters are OK as long as it's short \u2026 i'm not exactly sure how this can be future-proof",
          "createdAt": "2024-08-15T14:56:57Z",
          "updatedAt": "2024-08-15T14:56:57Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "OWNER",
          "body": "There could be two things said in a media-type parameter:\r\n\r\n1. The representation could be using \"these\" stand-in tags (probably enumerated by tag number)\r\n2. The representation does not use legacy for \"these\" stand-in tags (i.e., is suitable for implementations that are legacy-intolerant)\r\n\r\n2 obviously implies 1.\r\n\r\nUsing tag numbers to enumerate stand-in-features is somewhat icky, but I cannot come up with a better idea at the moment -- clearly, we need some extensibility here, and tag numbers provide that.\r\n(We probably want to minimize the combinatorial explosion, so maybe bulking up some tags, e.g., 54 implies 52 and is the only one used here, might be useful.)",
          "createdAt": "2024-08-15T15:03:40Z",
          "updatedAt": "2024-08-15T15:03:40Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOLF7SWM6RYdnm",
      "title": "support RFC 6991 hex-string and related",
      "url": "https://github.com/cabo/yang-standin/issues/5",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RFC 6991 defines hex-string as well as the related phys-address and mac-address.\r\nThey all are hex-strings built out of 2 hex digits per byte, with colons (':') interspersed.\r\n\r\nmac-address is exactly 6 bytes:\r\n\r\n         pattern '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}';\r\n\r\nhex-string and phys-address are zero or more bytes:\r\n\r\n         pattern '([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?';\r\n\r\nWo do have tag 48 for a MAC address in this hex-string form, but this probably could cause validation issues if we use that for lengths not allowed for MAC addresses.\r\n\r\nhex-strings are canonically lower-case, but upper-case is allowed as well.  Not sure what the incidence for upper case is.  Might need two new tags: hex-string (lower case), hex-string (upper case).",
      "createdAt": "2024-07-31T04:46:19Z",
      "updatedAt": "2024-08-19T14:55:23Z",
      "closedAt": "2024-08-19T14:55:23Z",
      "comments": [
        {
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "body": "i would favor converting hex strings to binary blobs, dropping the lower/upper case thing altogether\r\n\r\nthere is certain semantics in the data and abusing the specs to store _something_ in the upper/lower case is just adding unnecessary problems\r\n\r\nif somebody insists on keeping irrelevant information in the data, they shall stay with legacy",
          "createdAt": "2024-08-15T14:38:31Z",
          "updatedAt": "2024-08-15T14:38:31Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "OWNER",
          "body": "Im pretty sure we do not want to create a situation where we encode uppercase/lowercase together with the actual binary (byte string) data.\r\nHowever, we need to make some recommendations how to cope with non-canonical representations in an intermediate encoder; I would lean towards encouraging aggressive encoding (i.e., lose the difference), but enabling keeping legacy encoding for encoders that are not legacy-eschewing.\r\nThat difference needs to be part of our negotiation model, so constrained implementations (that are likely to be legacy-eschewing encoders as well as intolerant decoders) get good support.",
          "createdAt": "2024-08-15T14:51:11Z",
          "updatedAt": "2024-08-15T14:51:11Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOLF7SWM6THcZK",
      "title": "Specify a way how to add a local / custom stand-in",
      "url": "https://github.com/cabo/yang-standin/issues/7",
      "state": "OPEN",
      "author": "marenamat",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If the model defines its own compound data, it may as well make use of some private tags or experimental values. We should at least outline how to do this.",
      "createdAt": "2024-08-15T14:42:48Z",
      "updatedAt": "2024-08-15T14:46:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "OWNER",
          "body": "Right.  Is that something we need to do in this document?\r\nIt seems to me stand-ins need to be made ready-to-use using the approaches defined in the current document, and we can always add a YANG extension later to cover the development of new stand-ins.\r\nThere should be no requirement to touch the models in order to be able to define a new stand-in tag.",
          "createdAt": "2024-08-15T14:46:45Z",
          "updatedAt": "2024-08-15T14:46:45Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOLF7SWM6TICg8",
      "title": "(editorial): negative formulation used for \"legacy-eschewing encoder\"",
      "url": "https://github.com/cabo/yang-standin/issues/8",
      "state": "OPEN",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "              I'm a bit concerned about the negative formulation used here; slightly preferring something like this:\r\n\r\n> An encoder that always generates stand-in tags instead of legacy representations in places where stand-in tags are allowed.\r\n\r\n_Originally posted by @marenamat in https://github.com/cabo/yang-standin/pull/6#discussion_r1718459341_\r\n            ",
      "createdAt": "2024-08-15T15:53:03Z",
      "updatedAt": "2024-08-15T15:53:03Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOLF7SWM5kXAWR",
      "title": "Updates on IP address and prefix representation",
      "url": "https://github.com/cabo/yang-standin/pull/1",
      "state": "MERGED",
      "author": "marenamat",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-17T21:57:39Z",
      "updatedAt": "2024-02-21T13:04:51Z",
      "baseRepository": "cabo/yang-standin",
      "baseRefName": "main",
      "baseRefOid": "5292c56a4563166faa8aebeb559a1880f07ee8fd",
      "headRepository": "marenamat/yang-standin",
      "headRefName": "mm-ip",
      "headRefOid": "ca5d6f0c2e41d727862805b6e9e4df1c6079463d",
      "closedAt": "2024-02-21T13:04:51Z",
      "mergedAt": "2024-02-21T13:04:51Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "4a31bd5cad8ea82488227831d044a84db229a20a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLF7SWM5s_D1g",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks!\r\n\r\nApproved this with a few suggestions.",
          "createdAt": "2024-01-18T00:20:07Z",
          "updatedAt": "2024-01-18T00:28:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't think I know what an encoder is here.\r\nThe conversion from stand-in tag to a legacy representation?",
              "createdAt": "2024-01-18T00:20:07Z",
              "updatedAt": "2024-01-18T00:28:32Z"
            },
            {
              "originalPosition": 39,
              "body": "We tend not to use RFC 2119 keywords for documentation requirements.",
              "createdAt": "2024-01-18T00:20:32Z",
              "updatedAt": "2024-01-18T05:50:54Z"
            },
            {
              "originalPosition": 42,
              "body": "normalize with or prefixes with?  (Maybe an in-line example would clarify this.)",
              "createdAt": "2024-01-18T00:21:25Z",
              "updatedAt": "2024-01-18T00:28:32Z"
            },
            {
              "originalPosition": 49,
              "body": "In 9164, address-and-prefix doesn't get trailing zeros cut off, while prefixes do.",
              "createdAt": "2024-01-18T00:23:45Z",
              "updatedAt": "2024-01-18T00:28:32Z"
            },
            {
              "originalPosition": 58,
              "body": "The sourcecode-type for pretty-printed hex CBOR is \"cbor-pretty\"\r\n\r\nSo this should become ` ``` cbor-pretty ` \r\n(Don't know how to encode a suggestion with ` ``` ` in it...)",
              "createdAt": "2024-01-18T00:25:32Z",
              "updatedAt": "2024-01-18T00:28:32Z"
            },
            {
              "originalPosition": 113,
              "body": "One editorial question would be how many of the examples should be cbor-pretty and when we can use the more compact and easy to read cbor-diag -- cbor-pretty obviously visualizes the savings much better.",
              "createdAt": "2024-01-18T00:27:59Z",
              "updatedAt": "2024-01-18T00:28:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tAp0R",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T05:52:26Z",
          "updatedAt": "2024-01-18T05:52:27Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nformat. Specifically, if the schema allows to encode 2001:db8:1234::/48 both as\r\n```",
              "createdAt": "2024-01-18T05:52:26Z",
              "updatedAt": "2024-01-18T05:52:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tAqCn",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T05:53:25Z",
          "updatedAt": "2024-01-18T05:53:25Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "We probably need to address unions in general.\r\nPut in https://github.com/cabo/yang-standin/issues/2",
              "createdAt": "2024-01-18T05:53:25Z",
              "updatedAt": "2024-01-18T05:55:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tCwkf",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T11:12:17Z",
          "updatedAt": "2024-01-18T11:12:17Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Added a definition to the top.",
              "createdAt": "2024-01-18T11:12:17Z",
              "updatedAt": "2024-01-18T11:12:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tCwth",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T11:12:38Z",
          "updatedAt": "2024-01-18T11:12:38Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Fixed, thanks. (This is my first RFC, please be patient.)",
              "createdAt": "2024-01-18T11:12:38Z",
              "updatedAt": "2024-01-18T11:12:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tCw0j",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T11:12:53Z",
          "updatedAt": "2024-01-18T11:12:53Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "clarified, hopefully",
              "createdAt": "2024-01-18T11:12:53Z",
              "updatedAt": "2024-01-18T11:12:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tCyk8",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T11:17:09Z",
          "updatedAt": "2024-01-18T11:17:09Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "covered by #2, removing here",
              "createdAt": "2024-01-18T11:17:09Z",
              "updatedAt": "2024-01-18T11:17:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5tCyr5",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T11:17:25Z",
          "updatedAt": "2024-01-18T11:17:26Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "fixed",
              "createdAt": "2024-01-18T11:17:25Z",
              "updatedAt": "2024-01-18T11:17:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM5w1trK",
          "commit": {
            "abbreviatedOid": "ec59a0d"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T12:55:51Z",
          "updatedAt": "2024-02-21T12:55:52Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "(Now #3)",
              "createdAt": "2024-02-21T12:55:52Z",
              "updatedAt": "2024-02-21T12:55:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOLF7SWM54QbSL",
      "title": "August updates",
      "url": "https://github.com/cabo/yang-standin/pull/6",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Start writing up updates for -01 revision (due 2024-08-23)",
      "createdAt": "2024-08-13T16:42:55Z",
      "updatedAt": "2024-08-15T15:54:34Z",
      "baseRepository": "cabo/yang-standin",
      "baseRefName": "main",
      "baseRefOid": "4a31bd5cad8ea82488227831d044a84db229a20a",
      "headRepository": "cabo/yang-standin",
      "headRefName": "august-updates",
      "headRefOid": "a26e6518d01a2206ea9bac828e546b395b2703e8",
      "closedAt": "2024-08-15T15:54:34Z",
      "mergedAt": "2024-08-15T15:54:34Z",
      "mergedBy": "cabo",
      "mergeCommit": {
        "oid": "982aa82701bc2c62c5b297c5895965961cc6dafa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOLF7SWM6Fiwks",
          "commit": {
            "abbreviatedOid": "8db95f4"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-15T14:12:01Z",
          "updatedAt": "2024-08-15T14:12:01Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I'm a bit concerned about the negative formulation used here; slightly preferring something like this:\r\n\r\n> An encoder that always generates stand-in tags instead of legacy representations in places where stand-in tags are allowed.",
              "createdAt": "2024-08-15T14:12:01Z",
              "updatedAt": "2024-08-15T14:12:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6Fi7xi",
          "commit": {
            "abbreviatedOid": "8db95f4"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "overall let's merge this and then move on with resolving the other issues",
          "createdAt": "2024-08-15T14:32:16Z",
          "updatedAt": "2024-08-15T14:34:02Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "I would say yes. If I'm not missing anything, this applies for the datetime items where the discrepancy between YANG and CBOR is substantial.",
              "createdAt": "2024-08-15T14:32:16Z",
              "updatedAt": "2024-08-15T14:34:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6FjGgl",
          "commit": {
            "abbreviatedOid": "8db95f4"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-15T14:52:04Z",
          "updatedAt": "2024-08-15T14:52:04Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Good point.  However, \"Legacy-Eschewing Encoder\" is itself a negative term; can we go fully positive?",
              "createdAt": "2024-08-15T14:52:04Z",
              "updatedAt": "2024-08-15T14:52:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6FjHBM",
          "commit": {
            "abbreviatedOid": "8db95f4"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-15T14:52:51Z",
          "updatedAt": "2024-08-15T14:52:51Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "I think my question was really \"should THIS document\" do that or do we do that separately, maybe based on a YANG extension to be defined.",
              "createdAt": "2024-08-15T14:52:51Z",
              "updatedAt": "2024-08-15T14:52:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "PR_kwDOLF7SWM54fTZ2",
      "title": "Close #5: define tag CPA113, also explain tag 37 for UUID",
      "url": "https://github.com/cabo/yang-standin/pull/9",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-15T17:04:16Z",
      "updatedAt": "2024-08-19T14:55:22Z",
      "baseRepository": "cabo/yang-standin",
      "baseRefName": "main",
      "baseRefOid": "982aa82701bc2c62c5b297c5895965961cc6dafa",
      "headRepository": "cabo/yang-standin",
      "headRefName": "hex-string",
      "headRefOid": "bbf3425c5943b63522513d0291e3be3c50a82a84",
      "closedAt": "2024-08-19T14:55:22Z",
      "mergedAt": "2024-08-19T14:55:22Z",
      "mergedBy": "marenamat",
      "mergeCommit": {
        "oid": "0e6aef26e905dceb67078dfa121df712b171bd14"
      },
      "comments": [
        {
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems all to work well, and the allocation of the new tag also makes a good sense. Well spotted that these hex strings would make use of standins as well as the already covered types. Thanks!",
          "createdAt": "2024-08-19T14:55:14Z",
          "updatedAt": "2024-08-19T14:55:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOLF7SWM54uM5D",
      "title": "Extended the standin usage texts",
      "url": "https://github.com/cabo/yang-standin/pull/10",
      "state": "OPEN",
      "author": "marenamat",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "this is my try on reworking the standin usage sections, and on defining how to specify the standin usage in standalone messages\r\n\r\nthere are _lots_ of formally bad wordings, i wanted first to state my intent to have something for discussion before actually putting the time into proper formal specification",
      "createdAt": "2024-08-19T11:11:51Z",
      "updatedAt": "2024-08-22T08:27:01Z",
      "baseRepository": "cabo/yang-standin",
      "baseRefName": "main",
      "baseRefOid": "0e6aef26e905dceb67078dfa121df712b171bd14",
      "headRepository": "marenamat/yang-standin",
      "headRefName": "maria-extended",
      "headRefOid": "66382d7d5096306d59bc24099a5e8ac611837e68",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "body": "rebased on current `main`",
          "createdAt": "2024-08-19T15:23:30Z",
          "updatedAt": "2024-08-19T15:23:30Z"
        },
        {
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "body": "\u2026 and pushed another change, now with the stand-in declaration YANG module actually valid (hopefully) and with an added proposed feature of tagmarking groupings.\r\n\r\nThe simplest usage I can think of: the server has some memory usage statistics and it is provided splitted by logical functional parts of the server. When a new logical part is added, the old client app/lib doesn't know about it but it can get at least the information that \"this specific part of the data is actually memory usage statistics\" and display it well to the user. Without the tagmarking, it would see just a map of weird numbers.",
          "createdAt": "2024-08-19T16:32:46Z",
          "updatedAt": "2024-08-19T16:32:46Z"
        },
        {
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "body": "> \u2026 proposed feature of tagmarking groupings.\r\n\r\nNow my mind finally came to a conclusion that this is probably not needed as soon as we adopt SIDs. This is much harder than I expected, tbh!\ud83e\udd26\ud83c\udffc\u200d\u2640\ufe0f",
          "createdAt": "2024-08-19T22:39:44Z",
          "updatedAt": "2024-08-19T22:39:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOLF7SWM6F1Igc",
          "commit": {
            "abbreviatedOid": "ac5b7ac"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Quick first reaction.\r\nWill look more closely later today.",
          "createdAt": "2024-08-19T11:19:53Z",
          "updatedAt": "2024-08-19T11:24:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That is RFC 9581 now.",
              "createdAt": "2024-08-19T11:19:53Z",
              "updatedAt": "2024-08-19T11:24:10Z"
            },
            {
              "originalPosition": 47,
              "body": "I didn't see a need to do these, as they already are binary (integers).",
              "createdAt": "2024-08-19T11:21:05Z",
              "updatedAt": "2024-08-19T11:24:10Z"
            },
            {
              "originalPosition": 145,
              "body": "That is opposite to what I would have decided -- I would have accepted a binary standin for a string that doesn't have a known date/time-y schema node.",
              "createdAt": "2024-08-19T11:23:44Z",
              "updatedAt": "2024-08-19T11:24:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6F26-Y",
          "commit": {
            "abbreviatedOid": "ac5b7ac"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-19T14:51:07Z",
          "updatedAt": "2024-08-19T14:51:07Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "This paragraph is explicitly targeted on intermediate encoders without schema. Let's say the intermediate encoder chooses hex string over date, and encodes `15:32:46` as `43 15 32 46`. But the schema (which the intermediate encoder isn't aware of) says `time`. This looks quite confusing for me when expecting either `68 31 35 3A 33 32 3A 34 36` or \u2026 aha, we don't have a tag for just a time not bound to a date, probably. That looks like an issue.\r\n\r\nAnyway, what I wanted to say, is that one string may actually have many different meanings depending on context, which is what we are already experiencing in BIRD configuration language. With that, I'm advocating for \"standins strictly only with schema\", otherwise we're getting into a rabbit hole of reinterpreting e.g. times to hex strings, or even some weirder things with e.g. BGP large communities \u2026 which can be also `15:32:46`, see draft-ietf-idr-bgp-model-17 and `bgp-large-community-type` \u2026 but this time encoded probably as something like `4C 00 00 00 0F 00 00 00 20 00 00 00 2E` probably with an appropriate tag. And that's what the implementors of CBOR decoders are going to hate us for if we allow it.",
              "createdAt": "2024-08-19T14:51:07Z",
              "updatedAt": "2024-08-19T14:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6F3Fdo",
          "commit": {
            "abbreviatedOid": "ac5b7ac"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-19T15:07:52Z",
          "updatedAt": "2024-08-19T15:07:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "fixed, thanks",
              "createdAt": "2024-08-19T15:07:52Z",
              "updatedAt": "2024-08-19T15:07:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6F3FxO",
          "commit": {
            "abbreviatedOid": "ac5b7ac"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-19T15:08:19Z",
          "updatedAt": "2024-08-19T15:08:19Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "you are completely right, dropped",
              "createdAt": "2024-08-19T15:08:19Z",
              "updatedAt": "2024-08-19T15:08:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6F_5sv",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "cabo",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "A few more detail comments, but I think we need to adjust our direction at some point.\r\nI wanted to keep this really simple, not inviting a lot of complexity.\r\nThis of course means there will be limited functionality, but I'm sure 80 % of the benefit can be had with 5 % of the complexity.",
          "createdAt": "2024-08-20T14:07:28Z",
          "updatedAt": "2024-08-20T14:21:14Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Why?  Tags 100 and 1 are significantly more compact.",
              "createdAt": "2024-08-20T14:07:28Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 45,
              "body": "This assumes an encoder encodes for a specific decoder.\r\nThis work will deploy much faster if encoders can simply jump the gun and encode.  So I think lots of optional functionality gets in the way of deployment massively.\r\n(I probably also need some examples for how you want to use tag 1001 -- just encoding a timezone hint for date and time that will be dicarded anyway doesn't sound like a good reason for 1001.)",
              "createdAt": "2024-08-20T14:10:31Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 65,
              "body": "I still like this as a constraint on the emitting system.",
              "createdAt": "2024-08-20T14:12:03Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 145,
              "body": "Do you have an example for a rfc 6991 \"time\"?\r\nI wasn't planning to spend time on this; tag 1001 of course can model this as the duration from a start-of-day (which is even more compact than a hex0string :-).",
              "createdAt": "2024-08-20T14:14:03Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 143,
              "body": "I wouldn't even mention this.",
              "createdAt": "2024-08-20T14:15:09Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 147,
              "body": "That would be a massive change to existing protocols.\r\nKills deployment.",
              "createdAt": "2024-08-20T14:15:53Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 213,
              "body": "Well, new types are added all the time.\r\nRunning this via a registry has the problem that the people adding types generally don't know or care about standin-tags.\r\nSo someone else would need to step in.\r\nThis is on of the reasons why I thought pattern-matching would be the best way foreard.",
              "createdAt": "2024-08-20T14:18:31Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            },
            {
              "originalPosition": 220,
              "body": "This parameter does not make a lot of sense for ACCEPT.",
              "createdAt": "2024-08-20T14:19:05Z",
              "updatedAt": "2024-08-20T14:21:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6GVl2r",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T08:13:21Z",
          "updatedAt": "2024-08-22T08:13:21Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Well, I thought I had a reason when I was writing it and then it just stayed there. I'm ok with dropping this now as I don't have a reason now.",
              "createdAt": "2024-08-22T08:13:21Z",
              "updatedAt": "2024-08-22T08:13:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6GVobt",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T08:18:09Z",
          "updatedAt": "2024-08-22T08:18:09Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "Not exactly sure what you're here about.\r\n",
              "createdAt": "2024-08-22T08:18:09Z",
              "updatedAt": "2024-08-22T08:18:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6GVpTv",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T08:19:49Z",
          "updatedAt": "2024-08-22T08:19:50Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "The registry would be more like informative than actually normative\u2026 but this probably shows that there is a different solution, maybe just a table on the cbor.io website or something like that.",
              "createdAt": "2024-08-22T08:19:49Z",
              "updatedAt": "2024-08-22T08:19:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6GVraP",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T08:23:19Z",
          "updatedAt": "2024-08-22T08:23:19Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I don't see much of a use of \"encoding for everybody / decoding from everybody\" without some more specs. This is kinda coupled with the principle of \"no standin without a schema\" for me\u2026 but i can be wrong / oblivious to something. ",
              "createdAt": "2024-08-22T08:23:19Z",
              "updatedAt": "2024-08-22T08:23:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6GVsWO",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T08:25:06Z",
          "updatedAt": "2024-08-22T08:25:06Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Also the 1001 tag should be usable e.g. for sending microsecond / nanosecond abaolute time directly without recalculating to floats. Gonna produce a specific example in the evening.",
              "createdAt": "2024-08-22T08:25:06Z",
              "updatedAt": "2024-08-22T08:25:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOLF7SWM6GVtaE",
          "commit": {
            "abbreviatedOid": "66382d7"
          },
          "author": "marenamat",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-22T08:27:01Z",
          "updatedAt": "2024-08-22T08:27:01Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Are you referencing the in-message negotiation? (i'm confused by the github frontend probably) ",
              "createdAt": "2024-08-22T08:27:01Z",
              "updatedAt": "2024-08-22T08:27:01Z"
            }
          ]
        }
      ]
    }
  ]
}